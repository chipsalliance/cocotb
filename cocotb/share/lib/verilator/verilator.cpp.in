#include "V%TOPLEVEL%.h"
#include "verilated.h"
#include "verilated_vpi.h"

#if VM_TRACE
# include <verilated_vcd_c.h>
#endif

vluint64_t main_time = 0;       // Current simulation time

double sc_time_stamp () {       // Called by $time in Verilog
    return main_time;           // converts to double, to match
    // what SystemC does
}

extern "C" {
void vlog_startup_routines_bootstrap(void);

vpiHandle vpi_register_systf(p_vpi_systf_data)
{
	return 0;
}
}

int main(int argc, char** argv, char** env) {
    Verilated::commandArgs(argc, argv);
    V%TOPLEVEL%* top = new V%TOPLEVEL%("COCOTB");

    // Enable TOP module bypassing
    VerilatedVpi::setBypassTop(true);

    vlog_startup_routines_bootstrap();
    VerilatedVpi::callCbs(cbStartOfSimulation);

#if VM_TRACE
    Verilated::traceEverOn(true);

    VerilatedVcdC *tfp = new VerilatedVcdC;
    top->trace(tfp, 99);
    tfp->open("dump.vcd");
#endif

    // Simple optimization. In endian_swapper gives about ~40% speedup
    // but can produce errors in some cases, so hidden behind switch
    bool skip_eval_value_change = false;
    const char *skip_eval_value_change_c = getenv("VERILATOR_SKIP_EVAL_VC");
    if (skip_eval_value_change_c && (skip_eval_value_change_c[0] == '1'))
        skip_eval_value_change = true;

    while (!Verilated::gotFinish()) {
        bool again = true;

        // We must evaluate whole design until we process all 'events'
        while (again) {
            again = false;

            // Evaluate design
            top->eval();

            // Call Value Change callbacks as eval()
            // can modify signals values
            if (!skip_eval_value_change)
                VerilatedVpi::callValueCbs();

            // Call registered Read-Write callbacks
            again = VerilatedVpi::callCbs(cbReadWriteSynch);

            // Call Value Change callbacks as cbReadWriteSynch
            // can modify signals values
            VerilatedVpi::callValueCbs();
        }

        // Call ReadOnly callbacks
        VerilatedVpi::callCbs(cbReadOnlySynch);

        // Call registered timed callbacks (e.g. clock timer)
        VerilatedVpi::callTimedCbs();

#if VM_TRACE
        tfp->dump(main_time);
#endif
        main_time++;

        // Call registered NextSimTime
        // It should be called in new slot before everything else
        VerilatedVpi::callCbs(cbNextSimTime);
    }

    VerilatedVpi::callCbs(cbEndOfSimulation);

#if VM_TRACE
    tfp->close();
#endif

    delete top;
    return 0;
}